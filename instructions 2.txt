
# 🔧 Plan for the Application
We are building a [PLACEHOLDER_APP_TYPE] using [PLACEHOLDER_STACK].

## Key Development Goals:
1. Follow Test-Driven Development (TDD): Write tests first, then code.
2. Ensure input validation and proper authentication for all critical paths.
3. Use modular, maintainable code with performance in mind.
4. Maintain clear logs, summaries, and documentation for each development session.
5. Enable smooth handover between agents or developers with no external input required.

# 📋 Requirements
- Use proper folder structure (`/src`, `/tests`, etc.)
- Auto-update `requirements.txt` or `package.json` when new dependencies are added.
- Write comprehensive unit/integration tests using `pytest` or project-appropriate framework.
- Validate all input, secure all endpoints.
- Document setup, run, and test instructions in `README.md`.
- Summarize all progress in `dev-log.txt` and `chat-summary.md`.
- Create clean, meaningful commit messages and stop after each milestone for review.

# ✅ Current State of Development
- No code exists yet.
- No files or folders have been created.
- Agent should begin by creating `README.md`, base folder structure, and dev environment instructions.

## Milestones
- ⏳ Initial scaffold: folders, README, .gitignore, virtualenv setup
- ⏳ Feature 1: User authentication
- ⏳ Feature 2: Secured user profile API
- ⏳ Feature 3: Admin dashboard
- ⏳ Feature 4: Public content API
- ⏳ Final testing, documentation, cleanup

# 🚦 Feature Selection Guidelines
- Implement features in the order listed.
- Skip dependent features if prerequisites are incomplete and document the reason.
- Update milestone status from ⏳ to ✅ after completion.

# 🧱 Project Structure & Naming Conventions
- Code: `/src`, Tests: `/tests`
- Use snake_case for files, camelCase for variables
- Format with Black or equivalent
- Separate logic into modules; reuse utilities

# ✅ TDD Enforcement Rules
- Write tests before code.
- Get test-plan.txt approved before implementation.
- Tests must cover valid, invalid, and edge cases.
- Keep tests isolated and repeatable.

# 📘 Documentation & Logging Rules
- Update `README.md` if setup, commands, or features change.
- Update `dev-log.txt` after each milestone.
- Summarize AI chat decisions in `chat-summary.md`.

# 📦 Deployment Readiness
- Ensure all features are ✅
- Pass all tests and linters
- README should be complete
- Package the code for release

# 🛠️ Troubleshooting Guidance
- Log errors clearly with context.
- Suggest resolution paths if stuck.
- Don’t patch bugs silently—log them and ask for confirmation.

# 🔁 Reusable Prompt for AI Agent Continuation
You are continuing the development of this application based on the plan in this file. Your tasks are:
1. Read all instructions and understand the current state.
2. Pick the next required feature or milestone.
3. Generate a test-plan for that feature and wait for user review.
4. Once test plan is approved, implement the feature using TDD.
5. After completing a step, update the "Current State of Development" section with details.
6. Always document new files, code functions, and design decisions.
7. After each round of work, append a new section in this file titled "What’s Next" with a TODO list for the next agent/developer.
8. Suggest clean and meaningful commit messages.

# 🧪 How to Generate test-plan.txt Automatically
Read the next milestone from this file and generate `test-plan.txt` with the following format:

Feature: [Feature Name]

Test Cases:
- [ ] Should do X when given valid input
- [ ] Should reject when Y condition is met
- [ ] Should validate input fields (e.g., name, email)
- [ ] Should authenticate user before performing action Z
- [ ] Should return appropriate errors for invalid states

Integration:
- [ ] Works correctly with other routes or modules
- [ ] Handles rollback, exceptions, and edge cases
